// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/xxhash.h`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen.yaml`.
///
class XxhashBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  XxhashBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  XxhashBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// !
  /// @brief Obtains the xxHash version.
  ///
  /// This is mostly useful when xxHash is compiled as a shared library,
  /// since the returned value comes from the library, as opposed to header file.
  ///
  /// @return @ref XXH_VERSION_NUMBER of the invoked library.
  int XXH_versionNumber() {
    return _XXH_versionNumber();
  }

  late final _XXH_versionNumberPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'XXH_versionNumber');
  late final _XXH_versionNumber =
      _XXH_versionNumberPtr.asFunction<int Function()>();

  /// !
  /// @brief Calculates the 32-bit hash of @p input using xxHash32.
  ///
  /// @param input The block of data to be hashed, at least @p length bytes in size.
  /// @param length The length of @p input, in bytes.
  /// @param seed The 32-bit seed to alter the hash's output predictably.
  ///
  /// @pre
  /// The memory between @p input and @p input + @p length must be valid,
  /// readable, contiguous memory. However, if @p length is `0`, @p input may be
  /// `NULL`. In C++, this also must be *TriviallyCopyable*.
  ///
  /// @return The calculated 32-bit xxHash32 value.
  ///
  /// @see @ref single_shot_example "Single Shot Example" for an example.
  int XXH32(
    ffi.Pointer<ffi.Void> input,
    int length,
    int seed,
  ) {
    return _XXH32(
      input,
      length,
      seed,
    );
  }

  late final _XXH32Ptr = _lookup<
      ffi.NativeFunction<
          XXH32_hash_t Function(
              ffi.Pointer<ffi.Void>, ffi.Size, XXH32_hash_t)>>('XXH32');
  late final _XXH32 =
      _XXH32Ptr.asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// !
  /// @brief Allocates an @ref XXH32_state_t.
  ///
  /// @return An allocated pointer of @ref XXH32_state_t on success.
  /// @return `NULL` on failure.
  ///
  /// @note Must be freed with XXH32_freeState().
  ///
  /// @see @ref streaming_example "Streaming Example"
  ffi.Pointer<XXH32_state_t> XXH32_createState() {
    return _XXH32_createState();
  }

  late final _XXH32_createStatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<XXH32_state_t> Function()>>(
          'XXH32_createState');
  late final _XXH32_createState =
      _XXH32_createStatePtr.asFunction<ffi.Pointer<XXH32_state_t> Function()>();

  /// !
  /// @brief Frees an @ref XXH32_state_t.
  ///
  /// @param statePtr A pointer to an @ref XXH32_state_t allocated with @ref XXH32_createState().
  ///
  /// @return @ref XXH_OK.
  ///
  /// @note @p statePtr must be allocated with XXH32_createState().
  ///
  /// @see @ref streaming_example "Streaming Example"
  int XXH32_freeState(
    ffi.Pointer<XXH32_state_t> statePtr,
  ) {
    return _XXH32_freeState(
      statePtr,
    );
  }

  late final _XXH32_freeStatePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<XXH32_state_t>)>>(
      'XXH32_freeState');
  late final _XXH32_freeState = _XXH32_freeStatePtr.asFunction<
      int Function(ffi.Pointer<XXH32_state_t>)>();

  /// !
  /// @brief Copies one @ref XXH32_state_t to another.
  ///
  /// @param dst_state The state to copy to.
  /// @param src_state The state to copy from.
  /// @pre
  /// @p dst_state and @p src_state must not be `NULL` and must not overlap.
  void XXH32_copyState(
    ffi.Pointer<XXH32_state_t> dst_state,
    ffi.Pointer<XXH32_state_t> src_state,
  ) {
    return _XXH32_copyState(
      dst_state,
      src_state,
    );
  }

  late final _XXH32_copyStatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<XXH32_state_t>,
              ffi.Pointer<XXH32_state_t>)>>('XXH32_copyState');
  late final _XXH32_copyState = _XXH32_copyStatePtr.asFunction<
      void Function(ffi.Pointer<XXH32_state_t>, ffi.Pointer<XXH32_state_t>)>();

  /// !
  /// @brief Resets an @ref XXH32_state_t to begin a new hash.
  ///
  /// @param statePtr The state struct to reset.
  /// @param seed The 32-bit seed to alter the hash result predictably.
  ///
  /// @pre
  /// @p statePtr must not be `NULL`.
  ///
  /// @return @ref XXH_OK on success.
  /// @return @ref XXH_ERROR on failure.
  ///
  /// @note This function resets and seeds a state. Call it before @ref XXH32_update().
  ///
  /// @see @ref streaming_example "Streaming Example"
  int XXH32_reset(
    ffi.Pointer<XXH32_state_t> statePtr,
    int seed,
  ) {
    return _XXH32_reset(
      statePtr,
      seed,
    );
  }

  late final _XXH32_resetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<XXH32_state_t>, XXH32_hash_t)>>('XXH32_reset');
  late final _XXH32_reset = _XXH32_resetPtr.asFunction<
      int Function(ffi.Pointer<XXH32_state_t>, int)>();

  /// !
  /// @brief Consumes a block of @p input to an @ref XXH32_state_t.
  ///
  /// @param statePtr The state struct to update.
  /// @param input The block of data to be hashed, at least @p length bytes in size.
  /// @param length The length of @p input, in bytes.
  ///
  /// @pre
  /// @p statePtr must not be `NULL`.
  /// @pre
  /// The memory between @p input and @p input + @p length must be valid,
  /// readable, contiguous memory. However, if @p length is `0`, @p input may be
  /// `NULL`. In C++, this also must be *TriviallyCopyable*.
  ///
  /// @return @ref XXH_OK on success.
  /// @return @ref XXH_ERROR on failure.
  ///
  /// @note Call this to incrementally consume blocks of data.
  ///
  /// @see @ref streaming_example "Streaming Example"
  int XXH32_update(
    ffi.Pointer<XXH32_state_t> statePtr,
    ffi.Pointer<ffi.Void> input,
    int length,
  ) {
    return _XXH32_update(
      statePtr,
      input,
      length,
    );
  }

  late final _XXH32_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<XXH32_state_t>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('XXH32_update');
  late final _XXH32_update = _XXH32_updatePtr.asFunction<
      int Function(ffi.Pointer<XXH32_state_t>, ffi.Pointer<ffi.Void>, int)>();

  /// !
  /// @brief Returns the calculated hash value from an @ref XXH32_state_t.
  ///
  /// @param statePtr The state struct to calculate the hash from.
  ///
  /// @pre
  /// @p statePtr must not be `NULL`.
  ///
  /// @return The calculated 32-bit xxHash32 value from that state.
  ///
  /// @note
  /// Calling XXH32_digest() will not affect @p statePtr, so you can update,
  /// digest, and update again.
  ///
  /// @see @ref streaming_example "Streaming Example"
  int XXH32_digest(
    ffi.Pointer<XXH32_state_t> statePtr,
  ) {
    return _XXH32_digest(
      statePtr,
    );
  }

  late final _XXH32_digestPtr = _lookup<
      ffi.NativeFunction<
          XXH32_hash_t Function(ffi.Pointer<XXH32_state_t>)>>('XXH32_digest');
  late final _XXH32_digest =
      _XXH32_digestPtr.asFunction<int Function(ffi.Pointer<XXH32_state_t>)>();

  /// !
  /// @brief Converts an @ref XXH32_hash_t to a big endian @ref XXH32_canonical_t.
  ///
  /// @param dst  The @ref XXH32_canonical_t pointer to be stored to.
  /// @param hash The @ref XXH32_hash_t to be converted.
  ///
  /// @pre
  /// @p dst must not be `NULL`.
  ///
  /// @see @ref canonical_representation_example "Canonical Representation Example"
  void XXH32_canonicalFromHash(
    ffi.Pointer<XXH32_canonical_t> dst,
    int hash,
  ) {
    return _XXH32_canonicalFromHash(
      dst,
      hash,
    );
  }

  late final _XXH32_canonicalFromHashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<XXH32_canonical_t>,
              XXH32_hash_t)>>('XXH32_canonicalFromHash');
  late final _XXH32_canonicalFromHash = _XXH32_canonicalFromHashPtr.asFunction<
      void Function(ffi.Pointer<XXH32_canonical_t>, int)>();

  /// !
  /// @brief Converts an @ref XXH32_canonical_t to a native @ref XXH32_hash_t.
  ///
  /// @param src The @ref XXH32_canonical_t to convert.
  ///
  /// @pre
  /// @p src must not be `NULL`.
  ///
  /// @return The converted hash.
  ///
  /// @see @ref canonical_representation_example "Canonical Representation Example"
  int XXH32_hashFromCanonical(
    ffi.Pointer<XXH32_canonical_t> src,
  ) {
    return _XXH32_hashFromCanonical(
      src,
    );
  }

  late final _XXH32_hashFromCanonicalPtr = _lookup<
      ffi.NativeFunction<
          XXH32_hash_t Function(
              ffi.Pointer<XXH32_canonical_t>)>>('XXH32_hashFromCanonical');
  late final _XXH32_hashFromCanonical = _XXH32_hashFromCanonicalPtr.asFunction<
      int Function(ffi.Pointer<XXH32_canonical_t>)>();

  /// !
  /// @brief Calculates the 64-bit hash of @p input using xxHash64.
  ///
  /// @param input The block of data to be hashed, at least @p length bytes in size.
  /// @param length The length of @p input, in bytes.
  /// @param seed The 64-bit seed to alter the hash's output predictably.
  ///
  /// @pre
  /// The memory between @p input and @p input + @p length must be valid,
  /// readable, contiguous memory. However, if @p length is `0`, @p input may be
  /// `NULL`. In C++, this also must be *TriviallyCopyable*.
  ///
  /// @return The calculated 64-bit xxHash64 value.
  ///
  /// @see @ref single_shot_example "Single Shot Example" for an example.
  int XXH64(
    ffi.Pointer<ffi.Void> input,
    int length,
    int seed,
  ) {
    return _XXH64(
      input,
      length,
      seed,
    );
  }

  late final _XXH64Ptr = _lookup<
      ffi.NativeFunction<
          XXH64_hash_t Function(
              ffi.Pointer<ffi.Void>, ffi.Size, XXH64_hash_t)>>('XXH64');
  late final _XXH64 =
      _XXH64Ptr.asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// !
  /// @brief Allocates an @ref XXH64_state_t.
  ///
  /// @return An allocated pointer of @ref XXH64_state_t on success.
  /// @return `NULL` on failure.
  ///
  /// @note Must be freed with XXH64_freeState().
  ///
  /// @see @ref streaming_example "Streaming Example"
  ffi.Pointer<XXH64_state_t> XXH64_createState() {
    return _XXH64_createState();
  }

  late final _XXH64_createStatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<XXH64_state_t> Function()>>(
          'XXH64_createState');
  late final _XXH64_createState =
      _XXH64_createStatePtr.asFunction<ffi.Pointer<XXH64_state_t> Function()>();

  /// !
  /// @brief Frees an @ref XXH64_state_t.
  ///
  /// @param statePtr A pointer to an @ref XXH64_state_t allocated with @ref XXH64_createState().
  ///
  /// @return @ref XXH_OK.
  ///
  /// @note @p statePtr must be allocated with XXH64_createState().
  ///
  /// @see @ref streaming_example "Streaming Example"
  int XXH64_freeState(
    ffi.Pointer<XXH64_state_t> statePtr,
  ) {
    return _XXH64_freeState(
      statePtr,
    );
  }

  late final _XXH64_freeStatePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<XXH64_state_t>)>>(
      'XXH64_freeState');
  late final _XXH64_freeState = _XXH64_freeStatePtr.asFunction<
      int Function(ffi.Pointer<XXH64_state_t>)>();

  /// !
  /// @brief Copies one @ref XXH64_state_t to another.
  ///
  /// @param dst_state The state to copy to.
  /// @param src_state The state to copy from.
  /// @pre
  /// @p dst_state and @p src_state must not be `NULL` and must not overlap.
  void XXH64_copyState(
    ffi.Pointer<XXH64_state_t> dst_state,
    ffi.Pointer<XXH64_state_t> src_state,
  ) {
    return _XXH64_copyState(
      dst_state,
      src_state,
    );
  }

  late final _XXH64_copyStatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<XXH64_state_t>,
              ffi.Pointer<XXH64_state_t>)>>('XXH64_copyState');
  late final _XXH64_copyState = _XXH64_copyStatePtr.asFunction<
      void Function(ffi.Pointer<XXH64_state_t>, ffi.Pointer<XXH64_state_t>)>();

  /// !
  /// @brief Resets an @ref XXH64_state_t to begin a new hash.
  ///
  /// @param statePtr The state struct to reset.
  /// @param seed The 64-bit seed to alter the hash result predictably.
  ///
  /// @pre
  /// @p statePtr must not be `NULL`.
  ///
  /// @return @ref XXH_OK on success.
  /// @return @ref XXH_ERROR on failure.
  ///
  /// @note This function resets and seeds a state. Call it before @ref XXH64_update().
  ///
  /// @see @ref streaming_example "Streaming Example"
  int XXH64_reset(
    ffi.Pointer<XXH64_state_t> statePtr,
    int seed,
  ) {
    return _XXH64_reset(
      statePtr,
      seed,
    );
  }

  late final _XXH64_resetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<XXH64_state_t>, XXH64_hash_t)>>('XXH64_reset');
  late final _XXH64_reset = _XXH64_resetPtr.asFunction<
      int Function(ffi.Pointer<XXH64_state_t>, int)>();

  /// !
  /// @brief Consumes a block of @p input to an @ref XXH64_state_t.
  ///
  /// @param statePtr The state struct to update.
  /// @param input The block of data to be hashed, at least @p length bytes in size.
  /// @param length The length of @p input, in bytes.
  ///
  /// @pre
  /// @p statePtr must not be `NULL`.
  /// @pre
  /// The memory between @p input and @p input + @p length must be valid,
  /// readable, contiguous memory. However, if @p length is `0`, @p input may be
  /// `NULL`. In C++, this also must be *TriviallyCopyable*.
  ///
  /// @return @ref XXH_OK on success.
  /// @return @ref XXH_ERROR on failure.
  ///
  /// @note Call this to incrementally consume blocks of data.
  ///
  /// @see @ref streaming_example "Streaming Example"
  int XXH64_update(
    ffi.Pointer<XXH64_state_t> statePtr,
    ffi.Pointer<ffi.Void> input,
    int length,
  ) {
    return _XXH64_update(
      statePtr,
      input,
      length,
    );
  }

  late final _XXH64_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<XXH64_state_t>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('XXH64_update');
  late final _XXH64_update = _XXH64_updatePtr.asFunction<
      int Function(ffi.Pointer<XXH64_state_t>, ffi.Pointer<ffi.Void>, int)>();

  /// !
  /// @brief Returns the calculated hash value from an @ref XXH64_state_t.
  ///
  /// @param statePtr The state struct to calculate the hash from.
  ///
  /// @pre
  /// @p statePtr must not be `NULL`.
  ///
  /// @return The calculated 64-bit xxHash64 value from that state.
  ///
  /// @note
  /// Calling XXH64_digest() will not affect @p statePtr, so you can update,
  /// digest, and update again.
  ///
  /// @see @ref streaming_example "Streaming Example"
  int XXH64_digest(
    ffi.Pointer<XXH64_state_t> statePtr,
  ) {
    return _XXH64_digest(
      statePtr,
    );
  }

  late final _XXH64_digestPtr = _lookup<
      ffi.NativeFunction<
          XXH64_hash_t Function(ffi.Pointer<XXH64_state_t>)>>('XXH64_digest');
  late final _XXH64_digest =
      _XXH64_digestPtr.asFunction<int Function(ffi.Pointer<XXH64_state_t>)>();

  /// !
  /// @brief Converts an @ref XXH64_hash_t to a big endian @ref XXH64_canonical_t.
  ///
  /// @param dst The @ref XXH64_canonical_t pointer to be stored to.
  /// @param hash The @ref XXH64_hash_t to be converted.
  ///
  /// @pre
  /// @p dst must not be `NULL`.
  ///
  /// @see @ref canonical_representation_example "Canonical Representation Example"
  void XXH64_canonicalFromHash(
    ffi.Pointer<XXH64_canonical_t> dst,
    int hash,
  ) {
    return _XXH64_canonicalFromHash(
      dst,
      hash,
    );
  }

  late final _XXH64_canonicalFromHashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<XXH64_canonical_t>,
              XXH64_hash_t)>>('XXH64_canonicalFromHash');
  late final _XXH64_canonicalFromHash = _XXH64_canonicalFromHashPtr.asFunction<
      void Function(ffi.Pointer<XXH64_canonical_t>, int)>();

  /// !
  /// @brief Converts an @ref XXH64_canonical_t to a native @ref XXH64_hash_t.
  ///
  /// @param src The @ref XXH64_canonical_t to convert.
  ///
  /// @pre
  /// @p src must not be `NULL`.
  ///
  /// @return The converted hash.
  ///
  /// @see @ref canonical_representation_example "Canonical Representation Example"
  int XXH64_hashFromCanonical(
    ffi.Pointer<XXH64_canonical_t> src,
  ) {
    return _XXH64_hashFromCanonical(
      src,
    );
  }

  late final _XXH64_hashFromCanonicalPtr = _lookup<
      ffi.NativeFunction<
          XXH64_hash_t Function(
              ffi.Pointer<XXH64_canonical_t>)>>('XXH64_hashFromCanonical');
  late final _XXH64_hashFromCanonical = _XXH64_hashFromCanonicalPtr.asFunction<
      int Function(ffi.Pointer<XXH64_canonical_t>)>();

  /// !
  /// @brief Calculates 64-bit unseeded variant of XXH3 hash of @p input.
  ///
  /// @param input  The block of data to be hashed, at least @p length bytes in size.
  /// @param length The length of @p input, in bytes.
  ///
  /// @pre
  /// The memory between @p input and @p input + @p length must be valid,
  /// readable, contiguous memory. However, if @p length is `0`, @p input may be
  /// `NULL`. In C++, this also must be *TriviallyCopyable*.
  ///
  /// @return The calculated 64-bit XXH3 hash value.
  ///
  /// @note
  /// This is equivalent to @ref XXH3_64bits_withSeed() with a seed of `0`, however
  /// it may have slightly better performance due to constant propagation of the
  /// defaults.
  ///
  /// @see
  /// XXH3_64bits_withSeed(), XXH3_64bits_withSecret(): other seeding variants
  /// @see @ref single_shot_example "Single Shot Example" for an example.
  int XXH3_64bits(
    ffi.Pointer<ffi.Void> input,
    int length,
  ) {
    return _XXH3_64bits(
      input,
      length,
    );
  }

  late final _XXH3_64bitsPtr = _lookup<
      ffi.NativeFunction<
          XXH64_hash_t Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('XXH3_64bits');
  late final _XXH3_64bits =
      _XXH3_64bitsPtr.asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// !
  /// @brief Calculates 64-bit seeded variant of XXH3 hash of @p input.
  ///
  /// @param input  The block of data to be hashed, at least @p length bytes in size.
  /// @param length The length of @p input, in bytes.
  /// @param seed   The 64-bit seed to alter the hash result predictably.
  ///
  /// @pre
  /// The memory between @p input and @p input + @p length must be valid,
  /// readable, contiguous memory. However, if @p length is `0`, @p input may be
  /// `NULL`. In C++, this also must be *TriviallyCopyable*.
  ///
  /// @return The calculated 64-bit XXH3 hash value.
  ///
  /// @note
  /// seed == 0 produces the same results as @ref XXH3_64bits().
  ///
  /// This variant generates a custom secret on the fly based on default secret
  /// altered using the @p seed value.
  ///
  /// While this operation is decently fast, note that it's not completely free.
  ///
  /// @see @ref single_shot_example "Single Shot Example" for an example.
  int XXH3_64bits_withSeed(
    ffi.Pointer<ffi.Void> input,
    int length,
    int seed,
  ) {
    return _XXH3_64bits_withSeed(
      input,
      length,
      seed,
    );
  }

  late final _XXH3_64bits_withSeedPtr = _lookup<
      ffi.NativeFunction<
          XXH64_hash_t Function(ffi.Pointer<ffi.Void>, ffi.Size,
              XXH64_hash_t)>>('XXH3_64bits_withSeed');
  late final _XXH3_64bits_withSeed = _XXH3_64bits_withSeedPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// !
  /// @brief Calculates 64-bit variant of XXH3 with a custom "secret".
  ///
  /// @param data       The block of data to be hashed, at least @p len bytes in size.
  /// @param len        The length of @p data, in bytes.
  /// @param secret     The secret data.
  /// @param secretSize The length of @p secret, in bytes.
  ///
  /// @return The calculated 64-bit XXH3 hash value.
  ///
  /// @pre
  /// The memory between @p data and @p data + @p len must be valid,
  /// readable, contiguous memory. However, if @p length is `0`, @p data may be
  /// `NULL`. In C++, this also must be *TriviallyCopyable*.
  ///
  /// It's possible to provide any blob of bytes as a "secret" to generate the hash.
  /// This makes it more difficult for an external actor to prepare an intentional collision.
  /// The main condition is that @p secretSize *must* be large enough (>= @ref XXH3_SECRET_SIZE_MIN).
  /// However, the quality of the secret impacts the dispersion of the hash algorithm.
  /// Therefore, the secret _must_ look like a bunch of random bytes.
  /// Avoid "trivial" or structured data such as repeated sequences or a text document.
  /// Whenever in doubt about the "randomness" of the blob of bytes,
  /// consider employing @ref XXH3_generateSecret() instead (see below).
  /// It will generate a proper high entropy secret derived from the blob of bytes.
  /// Another advantage of using XXH3_generateSecret() is that
  /// it guarantees that all bits within the initial blob of bytes
  /// will impact every bit of the output.
  /// This is not necessarily the case when using the blob of bytes directly
  /// because, when hashing _small_ inputs, only a portion of the secret is employed.
  ///
  /// @see @ref single_shot_example "Single Shot Example" for an example.
  int XXH3_64bits_withSecret(
    ffi.Pointer<ffi.Void> data,
    int len,
    ffi.Pointer<ffi.Void> secret,
    int secretSize,
  ) {
    return _XXH3_64bits_withSecret(
      data,
      len,
      secret,
      secretSize,
    );
  }

  late final _XXH3_64bits_withSecretPtr = _lookup<
      ffi.NativeFunction<
          XXH64_hash_t Function(ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('XXH3_64bits_withSecret');
  late final _XXH3_64bits_withSecret = _XXH3_64bits_withSecretPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<XXH3_state_t> XXH3_createState() {
    return _XXH3_createState();
  }

  late final _XXH3_createStatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<XXH3_state_t> Function()>>(
          'XXH3_createState');
  late final _XXH3_createState =
      _XXH3_createStatePtr.asFunction<ffi.Pointer<XXH3_state_t> Function()>();

  int XXH3_freeState(
    ffi.Pointer<XXH3_state_t> statePtr,
  ) {
    return _XXH3_freeState(
      statePtr,
    );
  }

  late final _XXH3_freeStatePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<XXH3_state_t>)>>(
      'XXH3_freeState');
  late final _XXH3_freeState =
      _XXH3_freeStatePtr.asFunction<int Function(ffi.Pointer<XXH3_state_t>)>();

  /// !
  /// @brief Copies one @ref XXH3_state_t to another.
  ///
  /// @param dst_state The state to copy to.
  /// @param src_state The state to copy from.
  /// @pre
  /// @p dst_state and @p src_state must not be `NULL` and must not overlap.
  void XXH3_copyState(
    ffi.Pointer<XXH3_state_t> dst_state,
    ffi.Pointer<XXH3_state_t> src_state,
  ) {
    return _XXH3_copyState(
      dst_state,
      src_state,
    );
  }

  late final _XXH3_copyStatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<XXH3_state_t>,
              ffi.Pointer<XXH3_state_t>)>>('XXH3_copyState');
  late final _XXH3_copyState = _XXH3_copyStatePtr.asFunction<
      void Function(ffi.Pointer<XXH3_state_t>, ffi.Pointer<XXH3_state_t>)>();

  /// !
  /// @brief Resets an @ref XXH3_state_t to begin a new hash.
  ///
  /// @param statePtr The state struct to reset.
  ///
  /// @pre
  /// @p statePtr must not be `NULL`.
  ///
  /// @return @ref XXH_OK on success.
  /// @return @ref XXH_ERROR on failure.
  ///
  /// @note
  /// - This function resets `statePtr` and generate a secret with default parameters.
  /// - Call this function before @ref XXH3_64bits_update().
  /// - Digest will be equivalent to `XXH3_64bits()`.
  ///
  /// @see @ref streaming_example "Streaming Example"
  int XXH3_64bits_reset(
    ffi.Pointer<XXH3_state_t> statePtr,
  ) {
    return _XXH3_64bits_reset(
      statePtr,
    );
  }

  late final _XXH3_64bits_resetPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<XXH3_state_t>)>>(
      'XXH3_64bits_reset');
  late final _XXH3_64bits_reset = _XXH3_64bits_resetPtr.asFunction<
      int Function(ffi.Pointer<XXH3_state_t>)>();

  /// !
  /// @brief Resets an @ref XXH3_state_t with 64-bit seed to begin a new hash.
  ///
  /// @param statePtr The state struct to reset.
  /// @param seed     The 64-bit seed to alter the hash result predictably.
  ///
  /// @pre
  /// @p statePtr must not be `NULL`.
  ///
  /// @return @ref XXH_OK on success.
  /// @return @ref XXH_ERROR on failure.
  ///
  /// @note
  /// - This function resets `statePtr` and generate a secret from `seed`.
  /// - Call this function before @ref XXH3_64bits_update().
  /// - Digest will be equivalent to `XXH3_64bits_withSeed()`.
  ///
  /// @see @ref streaming_example "Streaming Example"
  int XXH3_64bits_reset_withSeed(
    ffi.Pointer<XXH3_state_t> statePtr,
    int seed,
  ) {
    return _XXH3_64bits_reset_withSeed(
      statePtr,
      seed,
    );
  }

  late final _XXH3_64bits_reset_withSeedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<XXH3_state_t>,
              XXH64_hash_t)>>('XXH3_64bits_reset_withSeed');
  late final _XXH3_64bits_reset_withSeed = _XXH3_64bits_reset_withSeedPtr
      .asFunction<int Function(ffi.Pointer<XXH3_state_t>, int)>();

  /// !
  /// @brief Resets an @ref XXH3_state_t with secret data to begin a new hash.
  ///
  /// @param statePtr The state struct to reset.
  /// @param secret     The secret data.
  /// @param secretSize The length of @p secret, in bytes.
  ///
  /// @pre
  /// @p statePtr must not be `NULL`.
  ///
  /// @return @ref XXH_OK on success.
  /// @return @ref XXH_ERROR on failure.
  ///
  /// @note
  /// `secret` is referenced, it _must outlive_ the hash streaming session.
  ///
  /// Similar to one-shot API, `secretSize` must be >= @ref XXH3_SECRET_SIZE_MIN,
  /// and the quality of produced hash values depends on secret's entropy
  /// (secret's content should look like a bunch of random bytes).
  /// When in doubt about the randomness of a candidate `secret`,
  /// consider employing `XXH3_generateSecret()` instead (see below).
  ///
  /// @see @ref streaming_example "Streaming Example"
  int XXH3_64bits_reset_withSecret(
    ffi.Pointer<XXH3_state_t> statePtr,
    ffi.Pointer<ffi.Void> secret,
    int secretSize,
  ) {
    return _XXH3_64bits_reset_withSecret(
      statePtr,
      secret,
      secretSize,
    );
  }

  late final _XXH3_64bits_reset_withSecretPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<XXH3_state_t>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('XXH3_64bits_reset_withSecret');
  late final _XXH3_64bits_reset_withSecret =
      _XXH3_64bits_reset_withSecretPtr.asFunction<
          int Function(
              ffi.Pointer<XXH3_state_t>, ffi.Pointer<ffi.Void>, int)>();

  /// !
  /// @brief Consumes a block of @p input to an @ref XXH3_state_t.
  ///
  /// @param statePtr The state struct to update.
  /// @param input The block of data to be hashed, at least @p length bytes in size.
  /// @param length The length of @p input, in bytes.
  ///
  /// @pre
  /// @p statePtr must not be `NULL`.
  /// @pre
  /// The memory between @p input and @p input + @p length must be valid,
  /// readable, contiguous memory. However, if @p length is `0`, @p input may be
  /// `NULL`. In C++, this also must be *TriviallyCopyable*.
  ///
  /// @return @ref XXH_OK on success.
  /// @return @ref XXH_ERROR on failure.
  ///
  /// @note Call this to incrementally consume blocks of data.
  ///
  /// @see @ref streaming_example "Streaming Example"
  int XXH3_64bits_update(
    ffi.Pointer<XXH3_state_t> statePtr,
    ffi.Pointer<ffi.Void> input,
    int length,
  ) {
    return _XXH3_64bits_update(
      statePtr,
      input,
      length,
    );
  }

  late final _XXH3_64bits_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<XXH3_state_t>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('XXH3_64bits_update');
  late final _XXH3_64bits_update = _XXH3_64bits_updatePtr.asFunction<
      int Function(ffi.Pointer<XXH3_state_t>, ffi.Pointer<ffi.Void>, int)>();

  /// !
  /// @brief Returns the calculated XXH3 64-bit hash value from an @ref XXH3_state_t.
  ///
  /// @param statePtr The state struct to calculate the hash from.
  ///
  /// @pre
  /// @p statePtr must not be `NULL`.
  ///
  /// @return The calculated XXH3 64-bit hash value from that state.
  ///
  /// @note
  /// Calling XXH3_64bits_digest() will not affect @p statePtr, so you can update,
  /// digest, and update again.
  ///
  /// @see @ref streaming_example "Streaming Example"
  int XXH3_64bits_digest(
    ffi.Pointer<XXH3_state_t> statePtr,
  ) {
    return _XXH3_64bits_digest(
      statePtr,
    );
  }

  late final _XXH3_64bits_digestPtr = _lookup<
          ffi.NativeFunction<XXH64_hash_t Function(ffi.Pointer<XXH3_state_t>)>>(
      'XXH3_64bits_digest');
  late final _XXH3_64bits_digest = _XXH3_64bits_digestPtr.asFunction<
      int Function(ffi.Pointer<XXH3_state_t>)>();

  /// !
  /// @brief Calculates 128-bit unseeded variant of XXH3 of @p data.
  ///
  /// @param data The block of data to be hashed, at least @p length bytes in size.
  /// @param len  The length of @p data, in bytes.
  ///
  /// @return The calculated 128-bit variant of XXH3 value.
  ///
  /// The 128-bit variant of XXH3 has more strength, but it has a bit of overhead
  /// for shorter inputs.
  ///
  /// This is equivalent to @ref XXH3_128bits_withSeed() with a seed of `0`, however
  /// it may have slightly better performance due to constant propagation of the
  /// defaults.
  ///
  /// @see XXH3_128bits_withSeed(), XXH3_128bits_withSecret(): other seeding variants
  /// @see @ref single_shot_example "Single Shot Example" for an example.
  XXH128_hash_t XXH3_128bits(
    ffi.Pointer<ffi.Void> data,
    int len,
  ) {
    return _XXH3_128bits(
      data,
      len,
    );
  }

  late final _XXH3_128bitsPtr = _lookup<
      ffi.NativeFunction<
          XXH128_hash_t Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('XXH3_128bits');
  late final _XXH3_128bits = _XXH3_128bitsPtr.asFunction<
      XXH128_hash_t Function(ffi.Pointer<ffi.Void>, int)>();

  /// ! @brief Calculates 128-bit seeded variant of XXH3 hash of @p data.
  ///
  /// @param data The block of data to be hashed, at least @p length bytes in size.
  /// @param len  The length of @p data, in bytes.
  /// @param seed The 64-bit seed to alter the hash result predictably.
  ///
  /// @return The calculated 128-bit variant of XXH3 value.
  ///
  /// @note
  /// seed == 0 produces the same results as @ref XXH3_64bits().
  ///
  /// This variant generates a custom secret on the fly based on default secret
  /// altered using the @p seed value.
  ///
  /// While this operation is decently fast, note that it's not completely free.
  ///
  /// @see XXH3_128bits(), XXH3_128bits_withSecret(): other seeding variants
  /// @see @ref single_shot_example "Single Shot Example" for an example.
  XXH128_hash_t XXH3_128bits_withSeed(
    ffi.Pointer<ffi.Void> data,
    int len,
    int seed,
  ) {
    return _XXH3_128bits_withSeed(
      data,
      len,
      seed,
    );
  }

  late final _XXH3_128bits_withSeedPtr = _lookup<
      ffi.NativeFunction<
          XXH128_hash_t Function(ffi.Pointer<ffi.Void>, ffi.Size,
              XXH64_hash_t)>>('XXH3_128bits_withSeed');
  late final _XXH3_128bits_withSeed = _XXH3_128bits_withSeedPtr.asFunction<
      XXH128_hash_t Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// !
  /// @brief Calculates 128-bit variant of XXH3 with a custom "secret".
  ///
  /// @param data       The block of data to be hashed, at least @p len bytes in size.
  /// @param len        The length of @p data, in bytes.
  /// @param secret     The secret data.
  /// @param secretSize The length of @p secret, in bytes.
  ///
  /// @return The calculated 128-bit variant of XXH3 value.
  ///
  /// It's possible to provide any blob of bytes as a "secret" to generate the hash.
  /// This makes it more difficult for an external actor to prepare an intentional collision.
  /// The main condition is that @p secretSize *must* be large enough (>= @ref XXH3_SECRET_SIZE_MIN).
  /// However, the quality of the secret impacts the dispersion of the hash algorithm.
  /// Therefore, the secret _must_ look like a bunch of random bytes.
  /// Avoid "trivial" or structured data such as repeated sequences or a text document.
  /// Whenever in doubt about the "randomness" of the blob of bytes,
  /// consider employing @ref XXH3_generateSecret() instead (see below).
  /// It will generate a proper high entropy secret derived from the blob of bytes.
  /// Another advantage of using XXH3_generateSecret() is that
  /// it guarantees that all bits within the initial blob of bytes
  /// will impact every bit of the output.
  /// This is not necessarily the case when using the blob of bytes directly
  /// because, when hashing _small_ inputs, only a portion of the secret is employed.
  ///
  /// @see @ref single_shot_example "Single Shot Example" for an example.
  XXH128_hash_t XXH3_128bits_withSecret(
    ffi.Pointer<ffi.Void> data,
    int len,
    ffi.Pointer<ffi.Void> secret,
    int secretSize,
  ) {
    return _XXH3_128bits_withSecret(
      data,
      len,
      secret,
      secretSize,
    );
  }

  late final _XXH3_128bits_withSecretPtr = _lookup<
      ffi.NativeFunction<
          XXH128_hash_t Function(ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('XXH3_128bits_withSecret');
  late final _XXH3_128bits_withSecret = _XXH3_128bits_withSecretPtr.asFunction<
      XXH128_hash_t Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// !
  /// @brief Resets an @ref XXH3_state_t to begin a new hash.
  ///
  /// @param statePtr The state struct to reset.
  ///
  /// @pre
  /// @p statePtr must not be `NULL`.
  ///
  /// @return @ref XXH_OK on success.
  /// @return @ref XXH_ERROR on failure.
  ///
  /// @note
  /// - This function resets `statePtr` and generate a secret with default parameters.
  /// - Call it before @ref XXH3_128bits_update().
  /// - Digest will be equivalent to `XXH3_128bits()`.
  ///
  /// @see @ref streaming_example "Streaming Example"
  int XXH3_128bits_reset(
    ffi.Pointer<XXH3_state_t> statePtr,
  ) {
    return _XXH3_128bits_reset(
      statePtr,
    );
  }

  late final _XXH3_128bits_resetPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<XXH3_state_t>)>>(
      'XXH3_128bits_reset');
  late final _XXH3_128bits_reset = _XXH3_128bits_resetPtr.asFunction<
      int Function(ffi.Pointer<XXH3_state_t>)>();

  /// !
  /// @brief Resets an @ref XXH3_state_t with 64-bit seed to begin a new hash.
  ///
  /// @param statePtr The state struct to reset.
  /// @param seed     The 64-bit seed to alter the hash result predictably.
  ///
  /// @pre
  /// @p statePtr must not be `NULL`.
  ///
  /// @return @ref XXH_OK on success.
  /// @return @ref XXH_ERROR on failure.
  ///
  /// @note
  /// - This function resets `statePtr` and generate a secret from `seed`.
  /// - Call it before @ref XXH3_128bits_update().
  /// - Digest will be equivalent to `XXH3_128bits_withSeed()`.
  ///
  /// @see @ref streaming_example "Streaming Example"
  int XXH3_128bits_reset_withSeed(
    ffi.Pointer<XXH3_state_t> statePtr,
    int seed,
  ) {
    return _XXH3_128bits_reset_withSeed(
      statePtr,
      seed,
    );
  }

  late final _XXH3_128bits_reset_withSeedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<XXH3_state_t>,
              XXH64_hash_t)>>('XXH3_128bits_reset_withSeed');
  late final _XXH3_128bits_reset_withSeed = _XXH3_128bits_reset_withSeedPtr
      .asFunction<int Function(ffi.Pointer<XXH3_state_t>, int)>();

  /// !
  /// @brief Resets an @ref XXH3_state_t with secret data to begin a new hash.
  ///
  /// @param statePtr   The state struct to reset.
  /// @param secret     The secret data.
  /// @param secretSize The length of @p secret, in bytes.
  ///
  /// @pre
  /// @p statePtr must not be `NULL`.
  ///
  /// @return @ref XXH_OK on success.
  /// @return @ref XXH_ERROR on failure.
  ///
  /// `secret` is referenced, it _must outlive_ the hash streaming session.
  /// Similar to one-shot API, `secretSize` must be >= @ref XXH3_SECRET_SIZE_MIN,
  /// and the quality of produced hash values depends on secret's entropy
  /// (secret's content should look like a bunch of random bytes).
  /// When in doubt about the randomness of a candidate `secret`,
  /// consider employing `XXH3_generateSecret()` instead (see below).
  ///
  /// @see @ref streaming_example "Streaming Example"
  int XXH3_128bits_reset_withSecret(
    ffi.Pointer<XXH3_state_t> statePtr,
    ffi.Pointer<ffi.Void> secret,
    int secretSize,
  ) {
    return _XXH3_128bits_reset_withSecret(
      statePtr,
      secret,
      secretSize,
    );
  }

  late final _XXH3_128bits_reset_withSecretPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<XXH3_state_t>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('XXH3_128bits_reset_withSecret');
  late final _XXH3_128bits_reset_withSecret =
      _XXH3_128bits_reset_withSecretPtr.asFunction<
          int Function(
              ffi.Pointer<XXH3_state_t>, ffi.Pointer<ffi.Void>, int)>();

  /// !
  /// @brief Consumes a block of @p input to an @ref XXH3_state_t.
  ///
  /// Call this to incrementally consume blocks of data.
  ///
  /// @param statePtr The state struct to update.
  /// @param input The block of data to be hashed, at least @p length bytes in size.
  /// @param length The length of @p input, in bytes.
  ///
  /// @pre
  /// @p statePtr must not be `NULL`.
  ///
  /// @return @ref XXH_OK on success.
  /// @return @ref XXH_ERROR on failure.
  ///
  /// @note
  /// The memory between @p input and @p input + @p length must be valid,
  /// readable, contiguous memory. However, if @p length is `0`, @p input may be
  /// `NULL`. In C++, this also must be *TriviallyCopyable*.
  int XXH3_128bits_update(
    ffi.Pointer<XXH3_state_t> statePtr,
    ffi.Pointer<ffi.Void> input,
    int length,
  ) {
    return _XXH3_128bits_update(
      statePtr,
      input,
      length,
    );
  }

  late final _XXH3_128bits_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<XXH3_state_t>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('XXH3_128bits_update');
  late final _XXH3_128bits_update = _XXH3_128bits_updatePtr.asFunction<
      int Function(ffi.Pointer<XXH3_state_t>, ffi.Pointer<ffi.Void>, int)>();

  /// !
  /// @brief Returns the calculated XXH3 128-bit hash value from an @ref XXH3_state_t.
  ///
  /// @param statePtr The state struct to calculate the hash from.
  ///
  /// @pre
  /// @p statePtr must not be `NULL`.
  ///
  /// @return The calculated XXH3 128-bit hash value from that state.
  ///
  /// @note
  /// Calling XXH3_128bits_digest() will not affect @p statePtr, so you can update,
  /// digest, and update again.
  XXH128_hash_t XXH3_128bits_digest(
    ffi.Pointer<XXH3_state_t> statePtr,
  ) {
    return _XXH3_128bits_digest(
      statePtr,
    );
  }

  late final _XXH3_128bits_digestPtr = _lookup<
          ffi
          .NativeFunction<XXH128_hash_t Function(ffi.Pointer<XXH3_state_t>)>>(
      'XXH3_128bits_digest');
  late final _XXH3_128bits_digest = _XXH3_128bits_digestPtr.asFunction<
      XXH128_hash_t Function(ffi.Pointer<XXH3_state_t>)>();

  /// !
  /// @brief Check equality of two XXH128_hash_t values
  ///
  /// @param h1 The 128-bit hash value.
  /// @param h2 Another 128-bit hash value.
  ///
  /// @return `1` if `h1` and `h2` are equal.
  /// @return `0` if they are not.
  int XXH128_isEqual(
    XXH128_hash_t h1,
    XXH128_hash_t h2,
  ) {
    return _XXH128_isEqual(
      h1,
      h2,
    );
  }

  late final _XXH128_isEqualPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(XXH128_hash_t, XXH128_hash_t)>>(
      'XXH128_isEqual');
  late final _XXH128_isEqual = _XXH128_isEqualPtr.asFunction<
      int Function(XXH128_hash_t, XXH128_hash_t)>();

  /// !
  /// @brief Compares two @ref XXH128_hash_t
  ///
  /// This comparator is compatible with stdlib's `qsort()`/`bsearch()`.
  ///
  /// @param h128_1 Left-hand side value
  /// @param h128_2 Right-hand side value
  ///
  /// @return >0 if @p h128_1  > @p h128_2
  /// @return =0 if @p h128_1 == @p h128_2
  /// @return <0 if @p h128_1  < @p h128_2
  int XXH128_cmp(
    ffi.Pointer<ffi.Void> h128_1,
    ffi.Pointer<ffi.Void> h128_2,
  ) {
    return _XXH128_cmp(
      h128_1,
      h128_2,
    );
  }

  late final _XXH128_cmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>('XXH128_cmp');
  late final _XXH128_cmp = _XXH128_cmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// !
  /// @brief Converts an @ref XXH128_hash_t to a big endian @ref XXH128_canonical_t.
  ///
  /// @param dst  The @ref XXH128_canonical_t pointer to be stored to.
  /// @param hash The @ref XXH128_hash_t to be converted.
  ///
  /// @pre
  /// @p dst must not be `NULL`.
  /// @see @ref canonical_representation_example "Canonical Representation Example"
  void XXH128_canonicalFromHash(
    ffi.Pointer<XXH128_canonical_t> dst,
    XXH128_hash_t hash,
  ) {
    return _XXH128_canonicalFromHash(
      dst,
      hash,
    );
  }

  late final _XXH128_canonicalFromHashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<XXH128_canonical_t>,
              XXH128_hash_t)>>('XXH128_canonicalFromHash');
  late final _XXH128_canonicalFromHash =
      _XXH128_canonicalFromHashPtr.asFunction<
          void Function(ffi.Pointer<XXH128_canonical_t>, XXH128_hash_t)>();

  /// !
  /// @brief Converts an @ref XXH128_canonical_t to a native @ref XXH128_hash_t.
  ///
  /// @param src The @ref XXH128_canonical_t to convert.
  ///
  /// @pre
  /// @p src must not be `NULL`.
  ///
  /// @return The converted hash.
  /// @see @ref canonical_representation_example "Canonical Representation Example"
  XXH128_hash_t XXH128_hashFromCanonical(
    ffi.Pointer<XXH128_canonical_t> src,
  ) {
    return _XXH128_hashFromCanonical(
      src,
    );
  }

  late final _XXH128_hashFromCanonicalPtr = _lookup<
      ffi.NativeFunction<
          XXH128_hash_t Function(
              ffi.Pointer<XXH128_canonical_t>)>>('XXH128_hashFromCanonical');
  late final _XXH128_hashFromCanonical = _XXH128_hashFromCanonicalPtr
      .asFunction<XXH128_hash_t Function(ffi.Pointer<XXH128_canonical_t>)>();
}

/// !
/// @brief Exit code for the streaming API.
abstract class XXH_errorcode {
  /// !< OK
  static const int XXH_OK = 0;

  /// !< Error
  static const int XXH_ERROR = 1;
}

typedef XXH32_hash_t = ffi.Uint32;
typedef DartXXH32_hash_t = int;

final class XXH32_state_s extends ffi.Opaque {}

/// !
/// @typedef struct XXH32_state_s XXH32_state_t
/// @brief The opaque state struct for the XXH32 streaming API.
///
/// @see XXH32_state_s for details.
/// @see @ref streaming_example "Streaming Example"
typedef XXH32_state_t = XXH32_state_s;

/// !
/// @brief Canonical (big endian) representation of @ref XXH32_hash_t.
final class XXH32_canonical_t extends ffi.Struct {
  /// !< Hash bytes, big endian
  @ffi.Array.multi([4])
  external ffi.Array<ffi.UnsignedChar> digest;
}

typedef XXH64_hash_t = ffi.Uint64;
typedef DartXXH64_hash_t = int;

final class XXH64_state_s extends ffi.Opaque {}

/// !
/// @brief The opaque state struct for the XXH64 streaming API.
///
/// @see XXH64_state_s for details.
/// @see @ref streaming_example "Streaming Example"
typedef XXH64_state_t = XXH64_state_s;

/// !
/// @brief Canonical (big endian) representation of @ref XXH64_hash_t.
final class XXH64_canonical_t extends ffi.Struct {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedChar> digest;
}

final class XXH3_state_s extends ffi.Opaque {}

/// !
/// @brief The opaque state struct for the XXH3 streaming API.
///
/// @see XXH3_state_s for details.
/// @see @ref streaming_example "Streaming Example"
typedef XXH3_state_t = XXH3_state_s;

/// !
/// @brief The return value from 128-bit hashes.
///
/// Stored in little endian order, although the fields themselves are in native
/// endianness.
final class XXH128_hash_t extends ffi.Struct {
  /// !< `value & 0xFFFFFFFFFFFFFFFF`
  @XXH64_hash_t()
  external int low64;

  /// !< `value >> 64`
  @XXH64_hash_t()
  external int high64;
}

/// Canonical representation
final class XXH128_canonical_t extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedChar> digest;
}

const int XXH_VERSION_MAJOR = 0;

const int XXH_VERSION_MINOR = 8;

const int XXH_VERSION_RELEASE = 3;

const int XXH_VERSION_NUMBER = 803;

const int XXH3_SECRET_SIZE_MIN = 136;

const int XXH3_SECRET_DEFAULT_SIZE = 192;
