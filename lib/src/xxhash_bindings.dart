// Copyright (c) 2015, the Dart project authors.
// All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// ignore_for_file: non_constant_identifier_names, constant_identifier_names
import 'dart:ffi' as ffi;

import 'package:xxhash/src/xxhash_bindings.g.dart';

class XxhashBindingsExtended extends XxhashBindings {
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  XxhashBindingsExtended(super.dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  XxhashBindingsExtended.fromLookup(super.lookup)
      : _lookup = lookup,
        super.fromLookup();

  ///!
  /// @brief Calculates 64/128-bit seeded variant of XXH3 hash of @p data.
  ///
  /// @param data       The block of data to be hashed, at least @p len bytes in size.
  /// @param len        The length of @p data, in bytes.
  /// @param secret     The secret data.
  /// @param secretSize The length of @p secret, in bytes.
  /// @param seed       The 64-bit seed to alter the hash result predictably.
  ///
  /// These variants generate hash values using either:
  /// - @p seed for "short" keys (< @ref XXH3_MIDSIZE_MAX = 240 bytes)
  /// - @p secret for "large" keys (>= @ref XXH3_MIDSIZE_MAX).
  ///
  /// This generally benefits speed, compared to `_withSeed()` or `_withSecret()`.
  /// `_withSeed()` has to generate the secret on the fly for "large" keys.
  /// It's fast, but can be perceptible for "not so large" keys (< 1 KB).
  /// `_withSecret()` has to generate the masks on the fly for "small" keys,
  /// which requires more instructions than _withSeed() variants.
  /// Therefore, _withSecretandSeed variant combines the best of both worlds.
  ///
  /// When @p secret has been generated by XXH3_generateSecret_fromSeed(),
  /// this variant produces *exactly* the same results as `_withSeed()` variant,
  /// hence offering only a pure speed benefit on "large" input,
  /// by skipping the need to regenerate the secret for every large input.
  ///
  /// Another usage scenario is to hash the secret to a 64-bit hash value,
  /// for example with XXH3_64bits(), which then becomes the seed,
  /// and then employ both the seed and the secret in _withSecretandSeed().
  /// On top of speed, an added benefit is that each bit in the secret
  /// has a 50% chance to swap each bit in the output, via its impact to the seed.
  ///
  /// This is not guaranteed when using the secret directly in "small data" scenarios,
  /// because only portions of the secret are employed for small data.
  int XXH3_64bits_withSecretandSeed(
    ffi.Pointer<ffi.Void> data,
    int len,
    ffi.Pointer<ffi.Void> secret,
    int secretSize,
    int seed,
  ) {
    return _XXH3_64bits_withSecretandSeed(data, len, secret, secretSize, seed);
  }

  late final _XXH3_64bits_withSecretandSeedPtr = _lookup<
      ffi.NativeFunction<
          XXH64_hash_t Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              XXH64_hash_t)>>('XXH3_64bits_withSecretandSeed');

  late final _XXH3_64bits_withSecretandSeed =
      _XXH3_64bits_withSecretandSeedPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int, int)>();

  ///!
  /// @brief Calculates 64/128-bit seeded variant of XXH3 hash of @p data.
  ///
  /// @param data       The block of data to be hashed, at least @p len bytes in size.
  /// @param len        The length of @p data, in bytes.
  /// @param secret     The secret data.
  /// @param secretSize The length of @p secret, in bytes.
  /// @param seed       The 64-bit seed to alter the hash result predictably.
  ///
  /// These variants generate hash values using either:
  /// - @p seed for "short" keys (< @ref XXH3_MIDSIZE_MAX = 240 bytes)
  /// - @p secret for "large" keys (>= @ref XXH3_MIDSIZE_MAX).
  ///
  /// This generally benefits speed, compared to `_withSeed()` or `_withSecret()`.
  /// `_withSeed()` has to generate the secret on the fly for "large" keys.
  /// It's fast, but can be perceptible for "not so large" keys (< 1 KB).
  /// `_withSecret()` has to generate the masks on the fly for "small" keys,
  /// which requires more instructions than _withSeed() variants.
  /// Therefore, _withSecretandSeed variant combines the best of both worlds.
  ///
  /// When @p secret has been generated by XXH3_generateSecret_fromSeed(),
  /// this variant produces *exactly* the same results as `_withSeed()` variant,
  /// hence offering only a pure speed benefit on "large" input,
  /// by skipping the need to regenerate the secret for every large input.
  ///
  /// Another usage scenario is to hash the secret to a 64-bit hash value,
  /// for example with XXH3_64bits(), which then becomes the seed,
  /// and then employ both the seed and the secret in _withSecretandSeed().
  /// On top of speed, an added benefit is that each bit in the secret
  /// has a 50% chance to swap each bit in the output, via its impact to the seed.
  ///
  /// This is not guaranteed when using the secret directly in "small data" scenarios,
  /// because only portions of the secret are employed for small data.
  XXH128_hash_t XXH3_128bits_withSecretandSeed(
    ffi.Pointer<ffi.Void> data,
    int len,
    ffi.Pointer<ffi.Void> secret,
    int secretSize,
    int seed,
  ) {
    return _XXH3_128bits_withSecretandSeed(data, len, secret, secretSize, seed);
  }

  late final _XXH3_128bits_withSecretandSeedPtr = _lookup<
      ffi.NativeFunction<
          XXH128_hash_t Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              XXH64_hash_t)>>('XXH3_128bits_withSecretandSeed');

  late final _XXH3_128bits_withSecretandSeed =
      _XXH3_128bits_withSecretandSeedPtr.asFunction<
          XXH128_hash_t Function(
              ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int, int)>();

  ///!
  /// @brief Derive a high-entropy secret from any user-defined content, named customSeed.
  ///
  /// @param secretBuffer    A writable buffer for derived high-entropy secret data.
  /// @param secretSize      Size of secretBuffer, in bytes.  Must be >= XXH3_SECRET_SIZE_MIN.
  /// @param customSeed      A user-defined content.
  /// @param customSeedSize  Size of customSeed, in bytes.
  ///
  /// @return @ref XXH_OK on success.
  /// @return @ref XXH_ERROR on failure.
  ///
  /// The generated secret can be used in combination with `*_withSecret()` functions.
  /// The `_withSecret()` variants are useful to provide a higher level of protection
  /// than 64-bit seed, as it becomes much more difficult for an external actor to
  /// guess how to impact the calculation logic.
  ///
  /// The function accepts as input a custom seed of any length and any content,
  /// and derives from it a high-entropy secret of length @p secretSize into an
  /// already allocated buffer @p secretBuffer.
  ///
  /// The generated secret can then be used with any `*_withSecret()` variant.
  /// The functions @ref XXH3_128bits_withSecret(), @ref XXH3_64bits_withSecret(),
  /// @ref XXH3_128bits_reset_withSecret() and @ref XXH3_64bits_reset_withSecret()
  /// are part of this list. They all accept a `secret` parameter
  /// which must be large enough for implementation reasons (>= @ref XXH3_SECRET_SIZE_MIN)
  /// _and_ feature very high entropy (consist of random-looking bytes).
  /// These conditions can be a high bar to meet, so @ref XXH3_generateSecret() can
  /// be employed to ensure proper quality.
  ///
  /// @p customSeed can be anything. It can have any size, even small ones,
  /// and its content can be anything, even "poor entropy" sources such as a bunch
  /// of zeroes. The resulting `secret` will nonetheless provide all required qualities.
  ///
  /// @pre
  ///   - @p secretSize must be >= @ref XXH3_SECRET_SIZE_MIN
  ///   - When @p customSeedSize > 0, supplying NULL as customSeed is undefined behavior.
  ///
  /// Example code:
  /// ```
  ///    // Hashes argv[2] using the entropy from argv[1].
  ///    int main(int argc, char* argv[])
  ///    {
  ///        char secret[XXH3_SECRET_SIZE_MIN];
  ///        if (argv != 3) { return 1; }
  ///        XXH3_generateSecret(secret, sizeof(secret), argv[1], strlen(argv[1]));
  ///        XXH64_hash_t h = XXH3_64bits_withSecret(
  ///             argv[2], strlen(argv[2]),
  ///             secret, sizeof(secret)
  ///        );
  ///        printf("%016llx\n", (unsigned long long) h);
  ///    }
  /// ```
  int XXH3_generateSecret(
    ffi.Pointer<ffi.Void> secret,
    int secretSize,
    ffi.Pointer<ffi.Void> customSeed,
    int customSeedSize,
  ) {
    return _XXH3_generateSecret(secret, secretSize, customSeed, customSeedSize);
  }

  late final _XXH3_generateSecretPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('XXH3_generateSecret');

  late final _XXH3_generateSecret = _XXH3_generateSecretPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  /// @brief Generate the same secret as the _withSeed() variants.
  ///
  /// @param secretBuffer A writable buffer of @ref XXH3_SECRET_DEFAULT_SIZE bytes
  /// @param seed         The 64-bit seed to alter the hash result predictably.
  ///
  /// The generated secret can be used in combination with
  ///`*_withSecret()` and `_withSecretandSeed()` variants.
  ///
  /// Example C++ `std::string` hash class:
  /// ```
  ///    #include <string>
  ///    #define XXH_STATIC_LINKING_ONLY // expose unstable API
  ///    #include "xxhash.h"
  ///    // Slow, seeds each time
  ///    class HashSlow {
  ///        XXH64_hash_t seed;
  ///    public:
  ///        HashSlow(XXH64_hash_t s) : seed{s} {}
  ///        size_t operator()(const std::string& x) const {
  ///            return size_t{XXH3_64bits_withSeed(x.c_str(), x.length(), seed)};
  ///        }
  ///    };
  ///    // Fast, caches the seeded secret for future uses.
  ///    class HashFast {
  ///        unsigned char secret[XXH3_SECRET_DEFAULT_SIZE];
  ///    public:
  ///        HashFast(XXH64_hash_t s) {
  ///            XXH3_generateSecret_fromSeed(secret, seed);
  ///        }
  ///        size_t operator()(const std::string& x) const {
  ///            return size_t{
  ///                XXH3_64bits_withSecret(x.c_str(), x.length(), secret, sizeof(secret))
  ///            };
  ///        }
  ///    };
  /// ```
  void XXH3_generateSecret_fromSeed(
    ffi.Pointer<ffi.Void> secret,
    int seed,
  ) {
    return _XXH3_generateSecret_fromSeed(secret, seed);
  }

  late final _XXH3_generateSecret_fromSeedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>,
              XXH64_hash_t)>>('XXH3_generateSecret_fromSeed');

  late final _XXH3_generateSecret_fromSeed = _XXH3_generateSecret_fromSeedPtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  /*!
 * @brief Resets an @ref XXH3_state_t with secret data to begin a new hash.
 *
 * @param statePtr   A pointer to an @ref XXH3_state_t allocated with @ref XXH3_createState().
 * @param secret     The secret data.
 * @param secretSize The length of @p secret, in bytes.
 * @param seed64     The 64-bit seed to alter the hash result predictably.
 *
 * @return @ref XXH_OK on success.
 * @return @ref XXH_ERROR on failure.
 *
 * @see XXH3_64bits_withSecretandSeed(). Contract is identical.
 */
  int XXH3_64bits_reset_withSecretandSeed(
    ffi.Pointer<XXH3_state_t> statePtr,
    ffi.Pointer<ffi.Void> secret,
    int secretSize,
    int seed,
  ) {
    return _XXH3_64bits_reset_withSecretandSeed(
        statePtr, secret, secretSize, seed);
  }

  late final _XXH3_64bits_reset_withSecretandSeedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<XXH3_state_t>, ffi.Pointer<ffi.Void>,
              ffi.Size, XXH64_hash_t)>>('XXH3_64bits_reset_withSecretandSeed');
  late final _XXH3_64bits_reset_withSecretandSeed =
      _XXH3_64bits_reset_withSecretandSeedPtr.asFunction<
          int Function(
              ffi.Pointer<XXH3_state_t>, ffi.Pointer<ffi.Void>, int, int)>();

  /*!
  * @brief Resets an @ref XXH3_state_t with secret data to begin a new hash.
  *
  * @param statePtr   A pointer to an @ref XXH3_state_t allocated with @ref XXH3_createState().
  * @param secret     The secret data.
  * @param secretSize The length of @p secret, in bytes.
  * @param seed64     The 64-bit seed to alter the hash result predictably.
  *
  * @return @ref XXH_OK on success.
  * @return @ref XXH_ERROR on failure.
  *
  * @see XXH3_64bits_withSecretandSeed(). Contract is identical.
  *
  * Note: there was a bug in an earlier version of this function (<= v0.8.2)
  * that would make it generate an incorrect hash value
  * when @p seed == 0 and @p length < XXH3_MIDSIZE_MAX
  * and @p secret is different from XXH3_generateSecret_fromSeed().
  * As stated in the contract, the correct hash result must be
  * the same as XXH3_128bits_withSeed() when @p length <= XXH3_MIDSIZE_MAX.
  * Results generated by this older version are wrong, hence not comparable.
  */
  int XXH3_128bits_reset_withSecretandSeed(
    ffi.Pointer<XXH3_state_t> statePtr,
    ffi.Pointer<ffi.Void> secret,
    int secretSize,
    int seed,
  ) {
    return _XXH3_128bits_reset_withSecretandSeed(
        statePtr, secret, secretSize, seed);
  }

  late final _XXH3_128bits_reset_withSecretandSeedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<XXH3_state_t>, ffi.Pointer<ffi.Void>,
              ffi.Size, XXH64_hash_t)>>('XXH3_128bits_reset_withSecretandSeed');
  late final _XXH3_128bits_reset_withSecretandSeed =
      _XXH3_128bits_reset_withSecretandSeedPtr.asFunction<
          int Function(
              ffi.Pointer<XXH3_state_t>, ffi.Pointer<ffi.Void>, int, int)>();
}

const int XXH3_MIDSIZE_MAX = 240;
