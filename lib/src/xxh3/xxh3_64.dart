// Copyright (c) 2015, the Dart project authors.
// All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

part of '../xxhash.dart';

/// Implementation of XXH3 64-bits family.
class XXH3Bits64 extends XXH3<int, XXH64_canonical_t> {
  const XXH3Bits64._() : super._();

  /// Implementation of XXH3 64-bits with a custom seed.
  ///
  /// [seed] == 0 produces the same results as [xxh3_64].
  ///
  /// This variant generates a custom secret on the fly based on default secret
  /// altered using the [seed] value.
  ///
  /// While this operation is decently fast, note that it's not completely free.
  factory XXH3Bits64.seed(int seed) => _XXH3Bits64Seeded(seed);

  /// Implementation of XXH3 64-bits with a custom secret.
  ///
  /// It's possible to provide any blob of bytes as a `secret` to generate the hash.
  /// This makes it more difficult for an external actor to prepare an intentional collision.
  /// The main condition is that [secret].length *must* be large enough (>= [XXHash.secretSizeMin]).
  ///
  /// However, the quality of the secret impacts the dispersion of the hash algorithm.
  /// Therefore, the secret _must_ look like a bunch of random bytes.
  ///
  /// Avoid "trivial" or structured data such as repeated sequences or a text document.
  /// Whenever in doubt about the "randomness" of the blob of bytes,
  /// consider employing [XXH3.generateSecret] instead (see below).
  ///
  /// It will generate a proper high entropy secret derived from the blob of bytes.
  /// Another advantage of using [XXH3.generateSecret] is that
  /// it guarantees that all bits within the initial blob of bytes
  /// will impact every bit of the output.
  ///
  /// This is not necessarily the case when using the blob of bytes directly
  /// because, when hashing _small_ inputs, only a portion of the secret is employed.
  factory XXH3Bits64.secret(Uint8List secret) => _XXH3Bits64Secret(secret);

  /// These variants generate hash values using either:
  /// - [seed] for "short" keys [XXHash.maxSeededInputByte]
  /// - [secret] for "large" keys [XXHash.maxSeededInputByte].
  ///
  /// This generally benefits speed, compared to [XXH3Bits64.seed] or [XXH3Bits64.secret].
  /// [XXH3Bits64.seed] has to generate the secret on the fly for "large" keys.
  /// It's fast, but can be perceptible for "not so large" keys (< 1 KB).
  /// [XXH3Bits64.secret]` has to generate the masks on the fly for "small" keys,
  /// which requires more instructions than [XXH3Bits64.seed] variants.
  /// Therefore, [XXH3Bits64.withSecretAndSeed] variant combines the best of both worlds.
  ///
  /// When [secret] has been generated by [XXH3.generateSecretFromSeed],
  /// this variant produces *exactly* the same results as [XXH3Bits64.seed] variant,
  /// hence offering only a pure speed benefit on "large" input,
  /// by skipping the need to regenerate the secret for every large input.
  ///
  /// Another usage scenario is to hash the secret to a 64-bit hash value,
  /// for example with [xxh3_64], which then becomes the seed,
  /// and then employ both the seed and the secret in [XXH3Bits64.withSecretAndSeed].
  /// On top of speed, an added benefit is that each bit in the secret
  /// has a 50% chance to swap each bit in the output, via its impact to the seed.
  ///
  /// This is not guaranteed when using the secret directly in "small data" scenarios,
  /// because only portions of the secret are employed for small data.
  factory XXH3Bits64.withSecretAndSeed(
    Uint8List secret,
    int seed,
  ) =>
      _XXH3Bits64SecretAndSeed(secret, seed);

  @override
  int _xxh(
    Pointer<Void> pointer,
    int length,
  ) =>
      _bindings.XXH3_64bits(
        pointer,
        length,
      );

  @override
  int get _digestSize => 8;

  @override
  _Canonical<XXH64_canonical_t> _canonicalFromHash(int hash) {
    Pointer<XXH64_canonical_t> pointer = calloc<XXH64_canonical_t>();

    _bindings.XXH64_canonicalFromHash(pointer, hash);

    return (pointer, pointer.ref.digest);
  }

  @override
  ByteConversionSink startChunkedConversion(Sink<Digest> sink) =>
      ByteConversionSink.from(_XXH3Bits64Sink(sink, _digest));
}

class _XXH3Bits64Sink extends _XXH3Sink<int> {
  _XXH3Bits64Sink(super.sink, super.digest);

  @override
  int hash(Pointer<XXH3_state_s> state) => _bindings.XXH3_64bits_digest(state);

  @override
  int reset(Pointer<XXH3_state_s> state) => _bindings.XXH3_64bits_reset(state);

  @override
  int update(Pointer<XXH3_state_s> state, Pointer<Void> data, int length) =>
      _bindings.XXH3_64bits_update(state, data, length);
}

class _XXH3Bits64Seeded extends XXH3Bits64 with _XXH3Seeded {
  _XXH3Bits64Seeded(int seed) : super._() {
    this.seed = seed;
  }

  @override
  int _xxh(
    Pointer<Void> pointer,
    int length,
  ) =>
      _bindings.XXH3_64bits_withSeed(
        pointer,
        length,
        seed,
      );

  @override
  ByteConversionSink startChunkedConversion(Sink<Digest> sink) =>
      ByteConversionSink.from(_XXH3Bits64SeededSink(sink, seed, _digest));
}

class _XXH3Bits64SeededSink extends _XXH3Bits64Sink with _XXH3Seeded {
  _XXH3Bits64SeededSink(super.sink, int seed, super.digest) {
    this.seed = seed;
  }

  @override
  int reset(Pointer<XXH3_state_s> state) =>
      _bindings.XXH3_64bits_reset_withSeed(state, seed);
}

class _XXH3Bits64Secret extends XXH3Bits64 with _XXH3Secret {
  _XXH3Bits64Secret(Uint8List secret) : super._() {
    this.secret = secret;
  }

  @override
  int _xxh(
    Pointer<Void> pointer,
    int length,
  ) {
    final secret = _pointer(this.secret);
    final hash = _bindings.XXH3_64bits_withSecret(
      pointer,
      length,
      secret,
      this.secret.length,
    );

    calloc.free(secret);
    return hash;
  }

  @override
  ByteConversionSink startChunkedConversion(Sink<Digest> sink) =>
      ByteConversionSink.from(_XXH3Bits64SecretSink(sink, secret, _digest));
}

class _XXH3Bits64SecretSink extends _XXH3Bits64Sink with _XXH3Secret {
  late final Pointer<Void> pointer;

  _XXH3Bits64SecretSink(super.sink, Uint8List secret, super.digest) {
    this.secret = secret;
    pointer = _pointer(secret);
  }

  @override
  int reset(Pointer<XXH3_state_s> state) =>
      _bindings.XXH3_64bits_reset_withSecret(
        state,
        pointer,
        secret.length,
      );

  @override
  void close() {
    super.close();
    calloc.free(pointer);
  }
}

class _XXH3Bits64SecretAndSeed extends XXH3Bits64
    with _XXH3Seeded, _XXH3Secret {
  _XXH3Bits64SecretAndSeed(Uint8List secret, int seed) : super._() {
    this.secret = secret;
    this.seed = seed;
  }

  @override
  int _xxh(
    Pointer<Void> pointer,
    int length,
  ) {
    final secret = _pointer(this.secret);
    final hash = _bindings.XXH3_64bits_withSecretandSeed(
      pointer,
      length,
      secret,
      this.secret.length,
      seed,
    );

    calloc.free(secret);
    return hash;
  }

  @override
  ByteConversionSink startChunkedConversion(Sink<Digest> sink) =>
      ByteConversionSink.from(
          _XXH3Bits64SecretAndSeedSink(sink, secret, seed, _digest));
}

class _XXH3Bits64SecretAndSeedSink extends _XXH3Bits64SecretSink
    with _XXH3Seeded {
  _XXH3Bits64SecretAndSeedSink(super.sink, super.secret, int seed, super.digest)
      : super() {
    this.seed = seed;
  }

  @override
  int reset(Pointer<XXH3_state_s> state) =>
      _bindings.XXH3_64bits_reset_withSecretandSeed(
        state,
        pointer,
        secret.length,
        seed,
      );
}
